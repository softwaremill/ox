---
description: Configure retries with appropriate schedules, result policies, and error conditions. Consider using adaptive retries for systemic failure scenarios.
globs: 
alwaysApply: false
---
# Ox Retry Configuration

Configure retries with appropriate schedules, result policies, and error conditions. Consider using adaptive retries for systemic failure scenarios.

**Basic retry with exponential backoff:**
```scala
val result = retry(
  Schedule.exponentialBackoff(100.millis)
    .maxAttempts(5)
    .maxInterval(30.seconds)
    .jitter()
) {
  callExternalService()
}
```

**Retry with custom result policies:**
```scala
given ResultPolicy[Either[ApiError, Data]] = ResultPolicy {
  case Left(ApiError.RateLimited) => ResultPolicy.Retry
  case Left(ApiError.Temporary) => ResultPolicy.Retry  
  case Left(ApiError.Permanent) => ResultPolicy.Fail
  case Right(_) => ResultPolicy.Success
}

val data = retry(Schedule.exponentialBackoff(1.second).maxAttempts(3)) {
  fetchFromAPI()
}
```

**Exception-based retry policies:**
```scala
val result = retry(
  Schedule.exponentialBackoff(500.millis).maxAttempts(10)
) {
  httpClient.get(url)
}.retryIf {
  case _: SocketTimeoutException => true
  case _: ConnectException => true
  case ex: HttpException if ex.status >= 500 => true
  case _ => false
}
```

**Adaptive retry for systemic failures:**
```scala
val adaptiveRetry = AdaptiveRetry(
  Schedule.exponentialBackoff(100.millis).maxInterval(10.seconds),
  successThreshold = 5,
  failureThreshold = 3
)

val result = adaptiveRetry.apply {
  criticalSystemCall()
}
```

**Guidelines:**
- Use jitter to prevent thundering herd
- Set appropriate max intervals and retry counts
- Distinguish between retryable and non-retryable errors
- Consider downstream system capacity
- Monitor retry metrics to tune parameters
