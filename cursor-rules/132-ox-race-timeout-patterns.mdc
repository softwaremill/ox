---
description: Use `race` for competing computations and `timeout` for operations that may run too long. Both properly handle interruption of losing branches.
globs: 
alwaysApply: false
---
# Ox Race and Timeout Patterns

Use `race` for competing computations and `timeout` for operations that may run too long. Both operations properly handle interruption and cleanup of losing branches.

## Race Patterns

### Basic Racing

```scala
import ox.{race, raceSuccess}

// Basic race - first completion wins
val result = race(
  primaryService.getData(),
  fallbackService.getData()
)

// Race for first successful result
val result2 = raceSuccess(
  primaryService.getData(),    // might throw
  fallbackService.getData(),   // might throw  
  cacheService.getData()       // fallback option
) // First successful result wins, failures are ignored
```

### Primary/Fallback Pattern

```scala
// Fast primary with slow fallback
def fetchWithFallback: T = race(
  primary,
  fallback
)

// With delay for fallback
def fetchWithDelayedFallback: T = race(
  primary,
  {
    sleep(100.millis) // Give primary a head start
    fallback
  }
)

// Real-world example
def getUserData(userId: String): UserData = race(
  cacheService.get(userId),
  {
    sleep(50.millis) // Prefer cache
    databaseService.get(userId)
  }
)
```

### Multiple Provider Pattern

```scala
// Race multiple data sources
def fetchFromMultipleAPIs(): ApiResponse = raceSuccess(
  apiProvider1.fetch(),
  apiProvider2.fetch(),
  apiProvider3.fetch(),
  fallbackProvider.fetch()
)

// Geographic distribution
def fetchFromClosestRegion(): Data = race(
  usEastService.getData(),
  usWestService.getData(),
  europeService.getData()
)
```

## Timeout Patterns

### Basic Timeout

```scala
import ox.timeout
import scala.concurrent.duration.*

// Simple timeout
val result = timeout(5.seconds) {
  expensiveOperation()
}

// Timeout with custom exception
val result2 = try {
  timeout(2.seconds) { networkCall() }
} catch {
  case _: TimeoutException => throw new ServiceUnavailableException()
}
```

### Timeout with Fallback

```scala
// Timeout with fallback value
def fetchWithTimeout: T = {
  try {
    timeout(duration) { operation }
  } catch {
    case _: TimeoutException => fallback
  }
}

// Usage
val userData = fetchWithTimeout(
  operation = expensiveUserLookup(userId),
  fallback = defaultUserData,
  duration = 3.seconds
)
```

### Cascading Timeouts

```scala
// Different timeout strategies
def fetchDataWithCascadingTimeouts(): Either[String, Data] = {
  // Try fast cache first
  try {
    Right(timeout(100.millis) { cacheService.get() })
  } catch {
    case _: TimeoutException =>
      // Try database with longer timeout
      try {
        Right(timeout(2.seconds) { databaseService.get() })
      } catch {
        case _: TimeoutException =>
          // Try external API with even longer timeout
          try {
            Right(timeout(10.seconds) { externalAPI.get() })
          } catch {
            case _: TimeoutException => Left("All sources timed out")
          }
      }
  }
}
```

## Combining Race and Timeout

### Timeout on Race

```scala
// Timeout the entire race operation
val result = timeout(5.seconds) {
  race(
    primaryService.getData(),
    secondaryService.getData()
  )
}
```

### Race with Timeout Fallback

```scala
// Race primary vs timeout fallback
def fetchWithTimeoutFallback(): Data = race(
  primaryService.getData(),
  {
    sleep(3.seconds)
    fallbackService.getData()
  }
)

// More complex: race with multiple fallback strategies
def fetchWithMultipleStrategies(): Data = raceSuccess(
  primaryService.getData(),
  timeout(5.seconds) { retryService.getData() },
  {
    sleep(2.seconds)
    cacheService.getData()
  }
)
```

## Error Handling in Race and Timeout

### Handling Race Failures

```scala
// All participants might fail
def safeRace(): Either[String, Data] = {
  try {
    Right(raceSuccess(
      primaryService.getData(),
      fallbackService.getData()
    ))
  } catch {
    case e: Exception => Left(s"All services failed: ${e.getMessage}")
  }
}

// Partial failure handling
def raceWithPartialFailure(): Option[Data] = {
  val results = List(
    () => primaryService.getData(),
    () => fallbackService.getData(),
    () => cacheService.getData()
  )
  
  // Try each service, return first success
  results.iterator.map { service =>
    try { Some(service()) }
    catch { case _: Exception => None }
  }.find(_.isDefined).flatten
}
```

### Timeout Error Handling

```scala
// Custom timeout handling
def handleTimeouts(): Either[String, Data] = {
  try {
    Right(timeout(5.seconds) { dataService.fetch() })
  } catch {
    case _: TimeoutException => Left("Service took too long")
    case e: Exception => Left(s"Service error: ${e.getMessage}")
  }
}

// Timeout with retry
def fetchWithRetryOnTimeout(): Data = {
  val maxAttempts = 3
  var attempts = 0
  
  while (attempts < maxAttempts) {
    try {
      return timeout(5.seconds) { dataService.fetch() }
    } catch {
      case _: TimeoutException =>
        attempts += 1
        if (attempts >= maxAttempts) throw new ServiceUnavailableException()
        sleep(1.second) // Back off between retries
    }
  }
  throw new IllegalStateException("Should not reach here")
}
```

## Real-World Examples

### API Gateway Pattern

```scala
class APIGateway {
  def fetchUserProfile(userId: String): Either[String, UserProfile] = {
    try {
      // Race multiple microservices
      val profile = raceSuccess(
        timeout(2.seconds) { userServiceA.getProfile(userId) },
        timeout(3.seconds) { userServiceB.getProfile(userId) },
        {
          sleep(1.second) // Prefer faster services
          cacheService.getCachedProfile(userId)
        }
      )
      Right(profile)
    } catch {
      case _: TimeoutException => Left("All services timed out")
      case e: Exception => Left(s"Service error: ${e.getMessage}")
    }
  }
}
```

### Database Connection Racing

```scala
class DatabasePool {
  def executeQuery: T = {
    // Race connections from pool
    raceSuccess(
      connection1.execute(query),
      connection2.execute(query),
      connection3.execute(query)
    )
  }
  
  def executeWithTimeout: T = {
    timeout(maxTime) {
      executeQuery(query)
    }
  }
}
```

### Circuit Breaker Integration

```scala
class ServiceClient {
  def callWithCircuitBreaker(): Data = {
    if (circuitBreaker.isOpen) {
      // Race fallback options when circuit is open
      race(
        cacheService.getData(),
        staticFallbackData()
      )
    } else {
      // Normal operation with timeout
      try {
        timeout(5.seconds) { primaryService.getData() }
      } catch {
        case _: TimeoutException =>
          circuitBreaker.recordFailure()
          throw new ServiceUnavailableException()
      }
    }
  }
}
```

### Batch Processing with Timeouts

```scala
class BatchProcessor {
  def processBatch(items: List[Item]): List[Either[String, Result]] = {
    supervised {
      items.mapPar(4) { item =>
        try {
          Right(timeout(30.seconds) { processItem(item) })
        } catch {
          case _: TimeoutException => Left(s"Processing timeout for item ${item.id}")
          case e: Exception => Left(s"Processing error: ${e.getMessage}")
        }
      }
    }
  }
}
```

## Performance Considerations

### Resource Management

```scala
// Efficient resource usage in race
def efficientRace(): Data = {
  // Don't start expensive operations unless needed
  race(
    fastCache.get(),
    {
      // Only start expensive operation if cache misses
      if (fastCache.isEmpty) expensiveComputation()
      else throw new RuntimeException("Not needed")
    }
  )
}
```

### Timeout Selection

```scala
// Context-aware timeout selection
def adaptiveTimeout(context: RequestContext): Duration = {
  context.priority match {
    case Priority.HIGH => 10.seconds
    case Priority.NORMAL => 5.seconds
    case Priority.LOW => 2.seconds
  }
}

def processWithAdaptiveTimeout(request: Request): Response = {
  val timeoutDuration = adaptiveTimeout(request.context)
  timeout(timeoutDuration) {
    processRequest(request)
  }
}
```

## Best Practices

1. **Use `raceSuccess`** when failures are expected and you want the first success
2. **Use `race`** when you want the first completion (success or failure)
3. **Set appropriate timeout values** based on operation characteristics
4. **Handle timeout exceptions** gracefully with fallbacks
5. **Consider resource costs** - don't race expensive operations unnecessarily
6. **Test timeout behavior** to ensure proper cleanup
7. **Use cascading timeouts** for multi-tier fallback strategies
8. **Monitor timeout frequencies** to optimize timeout values
9. **Combine with circuit breakers** for robust error handling
10. **Document timeout reasoning** for future maintenance

## Common Mistakes

```scala
// Bad: Not handling timeout exceptions
val result = timeout(5.seconds) { 
  expensiveOperation() 
} // TimeoutException can be thrown

// Good: Handle timeout exceptions
val result = try {
  timeout(5.seconds) { expensiveOperation() }
} catch {
  case _: TimeoutException => fallbackValue
}

// Bad: Racing expensive operations wastefully
race(
  expensiveComputation1(),
  expensiveComputation2()
) // Both computations start immediately

// Good: Smart racing with delays or conditions
race(
  expensiveComputation1(),
  {
    sleep(100.millis) // Give first computation a chance
    expensiveComputation2()
  }
)
```
