---
description: Use `using Ox` capability sparingly as it grants thread creation power. Avoid passing it through multiple method layers.
globs: 
alwaysApply: false
---
# Ox Using Ox Sparingly

Use `using Ox` capability sparingly as it grants thread creation power. Avoid passing it through multiple method layers.

**Bad - threading Ox through many layers:**
```scala
def processOrder(order: Order)(using Ox): Result = 
  val validated = validateOrder(order)
  val enriched = enrichOrder(validated)
  val saved = saveOrder(enriched)
  saved

def validateOrder(order: Order)(using Ox): Order = // Doesn't need Ox!
  if (order.isValid) order else throw InvalidOrder()

def enrichOrder(order: Order)(using Ox): Order = // Doesn't need Ox!
  order.copy(enrichedData = lookupData(order.id))
```

**Good - Ox only where concurrency is needed:**
```scala
def processOrder(order: Order)(using Ox): Result = 
  // Only the orchestration needs Ox
  val validationFork = fork { validateOrder(order) }
  val enrichmentFork = fork { enrichOrder(order) }
  
  val validated = validationFork.join()
  val enriched = enrichmentFork.join()
  saveOrder(validated, enriched)

def validateOrder(order: Order): Order = // Pure business logic
  if (order.isValid) order else throw InvalidOrder()

def enrichOrder(order: Order): Order = // Pure business logic  
  order.copy(enrichedData = lookupData(order.id))
```

**When to use `using Ox`:**
- Methods that create forks directly
- Orchestration/coordination logic
- Top-level application boundaries
- Integration points requiring concurrency

**When NOT to use `using Ox`:**
- Pure business logic
- Data transformation
- Validation functions
- Repository operations (unless truly concurrent)

Keep concurrency capabilities at the edges of your system.
