---
description: Use channels for integrating with callback-based APIs. Channels provide completable, queue-like communication with Go-like `select` features, without requiring structured context. 
globs: 
alwaysApply: false
---
# Ox Channel Integration

Use channels for integrating with callback-based APIs. Channels provide completable, queue-like communication with Go-like `select` features.

**Callback to channel integration:**
```scala
def subscribeToEvents()(using Ox, BufferCapacity): Source[Event] = 
  val channel = BufferCapacity.newChannel[Event]
  
  // Integrate with callback-based API
  eventSystem.subscribe { event =>
    channel.send(event) // Bridge callback to channel
  }
  
  channel
```

**Channel-based producer/consumer:**
```scala
supervised {
  val dataChannel = Channel.bufferedDefault[String]
  
  // Producer fork
  forkUser {
    while (hasMoreData) {
      val data = fetchData()
      dataChannel.send(data)
    }
    dataChannel.done()
  }
  
  // Consumer fork
  forkUser {
    dataChannel.drain(processData)
  }
}
```

**Go-like select operations:**
```scala
val results = Channel.rendezvous[String]
val errors = Channel.rendezvous[Exception]

select(
  results.receiveClause,
  errors.receiveClause,
  timeout(5.seconds).receiveClause
) match {
  case results.Received(value) => handleSuccess(value)
  case errors.Received(error) => handleError(error)
  case _ => handleTimeout()
}
```

**Channel-to-flow conversion:**
```scala
// Use channels for imperative logic, convert to flows for transformations
def createDataFlow()(using Ox, BufferCapacity): Flow[ProcessedData] =
  val source = subscribeToEvents() // Returns Source[Event] 
  Flow.fromSource(source)
    .filter(_.isImportant)
    .map(processEvent)
```

Channels excel at bridging imperative/callback code with Ox's structured concurrency.
