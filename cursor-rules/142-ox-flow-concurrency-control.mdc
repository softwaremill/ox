---
description: Use flow concurrency operators (`mapPar`, `buffer`, `merge`) to introduce asynchronous boundaries only when needed for performance.
globs: 
alwaysApply: false
---
# Ox Flow Concurrency Control

Use flow concurrency operators (`mapPar`, `buffer`, `merge`) to introduce asynchronous boundaries only when needed for performance.

**Sequential by default:**
```scala
// This runs sequentially on single thread
Flow.fromValues(1, 2, 3, 4, 5)
  .map(expensiveComputation)  // Processed one by one
  .filter(isValid)
  .runToList()
```

**Introduce concurrency strategically:**
```scala
// Add concurrency for I/O bound operations
Flow.fromValues(urls)
  .mapPar(4)(httpClient.get)    // Up to 4 concurrent HTTP calls
  .map(parseResponse)           // Back to sequential processing
  .runToList()
```

**Buffer for producer/consumer mismatch:**
```scala
Flow.fromValues(items)
  .map(fastProducer)            // Fast producer
  .buffer(100)                  // Buffer up to 100 elements
  .map(slowConsumer)            // Slow consumer
  .runDrain()
```

**Merge multiple flows:**
```scala
val flow1 = Flow.tick(100.millis, "fast")
val flow2 = Flow.tick(300.millis, "slow")

flow1.merge(flow2)              // Concurrent execution
  .take(20)
  .runForeach(println)
```

**Concurrency guidelines:**
- Start sequential, add concurrency where needed
- Use `mapPar` for I/O bound operations
- Use `buffer` for rate mismatches
- Consider downstream capacity when setting parallelism
- Monitor resource usage with high concurrency
