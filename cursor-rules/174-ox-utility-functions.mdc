---
description: Ox provides utility functions for common operations in direct-style code: `.pipe`, `.tap`, `.discard`, `uninterruptible` and `debug`. These are often inline methods with no runtime overhead.
globs: 
alwaysApply: false
---
# Ox Utility Functions

Ox provides utility functions for common operations in direct-style code: `.pipe`, `.tap`, `.discard`, `uninterruptible` and `debug`. These are often inline methods with no runtime overhead.

## Top-Level Utilities

```scala
import ox.{sleep, debug, uninterruptible}
import scala.concurrent.duration.*

// Scala-friendly sleep
sleep(2.seconds) // Better than Thread.sleep

// Debug printing with expression and value
debug(computeExpensiveValue()) // Prints: computeExpensiveValue() = 42

// Uninterruptible code blocks
uninterruptible {
  criticalCleanupOperation()
  updateImportantState()
} // Cannot be interrupted even if thread/fork is cancelled
```

## Extension Methods for Chaining

```scala
// Pipe - apply function and return result (useful for chaining)
val result = getData()
  .pipe(processData)
  .pipe(validateData)
  .pipe(formatData)

// Tap - apply function but return original value (useful for side effects)
val user = fetchUser(userId)
  .tap(u => logger.info(s"Fetched user: ${u.name}"))
  .tap(auditService.logAccess)
  .tap(cacheService.store)

// Discard - avoid "discarded non-unit value" warnings
computeValue().discard // Explicitly discard result
```

## Exception Handling Utilities

```scala
// Handle exceptions with side effects
val result = riskyOperation()
  .tapException(e => logger.error(s"Operation failed: ${e.getMessage}"))
  .tapNonFatalException(e => metrics.incrementErrorCounter())
```

## Future Integration

```scala
import scala.concurrent.Future

// Block on Future completion (direct-style integration)
val futureResult: Future[String] = asyncOperation()
val result: String = futureResult.get() // Blocks until complete
```

## Real-World Examples

```scala
// Data processing pipeline with utilities
def processUserData(userId: String): ProcessedUser = {
  fetchUser(userId)
    .tap(u => debug(u)) // Debug log the user
    .pipe(enrichUserData)
    .tap(cacheService.store) // Cache the enriched data
    .pipe(validateUser)
    .tapException(e => alertService.sendAlert(s"User processing failed: $e"))
}

// Critical operation that shouldn't be interrupted
def saveToDatabase(data: Data): Unit = uninterruptible {
  database.beginTransaction()
  database.save(data)
  database.commit()
  auditLog.record(s"Saved data: ${data.id}")
}

// Working with legacy async code
def integrateLegacyService(): String = {
  val futureData = legacyService.fetchDataAsync()
  val data = futureData.get() // Convert to direct-style
  
  processData(data)
    .tap(result => logger.info(s"Processed: $result"))
    .pipe(_.toString)
}
```

## Best Practices

1. **Use `pipe`** for transformation chains
2. **Use `tap`** for side effects that don't change the value
3. **Use `debug`** during development for easy debugging
4. **Use `uninterruptible`** for critical sections that must complete
5. **Use `.discard`** to explicitly ignore return values
6. **Use `.get()`** to integrate Future-based APIs into direct-style code

## Common Patterns

```scala
// Good: Clear data processing pipeline
data
  .pipe(validate)
  .tap(logValidation)
  .pipe(transform)
  .tap(cache.store)
  .pipe(serialize)

// Good: Critical cleanup with uninterruptible
uninterruptible {
  resource.close()
  tempFiles.cleanup()
  locks.release()
}

// Good: Debug complex expressions
val complexResult = debug {
  data.filter(_.isValid)
      .map(transform)
      .reduce(combine)
} // Shows both expression and result
```
