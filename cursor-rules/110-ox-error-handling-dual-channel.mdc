---
description: Ox uses two distinct channels for errors: exceptions for bugs/unexpected situations, and application errors as values (`Either`, union types).
globs: 
alwaysApply: false
---
# Ox Error Handling: Dual Channel

Ox uses two distinct channels for error handling: exceptions for bugs and unexpected situations, and application errors represented as values.

## Two Error Channels

1. **Exceptions**: For bugs, unexpected situations, integration with Java libraries
2. **Application errors**: Represented as values using `Either`, union types, or custom data types

## Exception Handling

Exceptions are handled by computation combinators and propagate normally:

```scala
import ox.{par, race, supervised, fork}

// Exceptions propagate through high-level operations
val result = par(
  computation1(), // might throw
  computation2()  // cancelled if computation1 throws
)

// Exceptions end supervised scopes
supervised {
  fork {
    sleep(1.second)
    println("This won't print")
  }
  fork {
    sleep(500.millis)
    throw new RuntimeException("boom!") // Ends entire scope
  }
}

// Use try/catch for exception handling
try {
  riskyOperation()
} catch {
  case e: SpecificException => handleError(e)
}
```

## Application Errors as Values

For type-safe error handling, use `Either` and error modes:

```scala
import ox.either
import ox.either.ok

case class User()
case class Organization()
case class Assignment(user: User, org: Organization)

def lookupUser(id: Int): Either[String, User] = ???
def lookupOrganization(id: Int): Either[String, Organization] = ???

// Use either block to unwrap values
val result: Either[String, Assignment] = either:
  val user = lookupUser(1).ok()
  val org = lookupOrganization(2).ok()
  Assignment(user, org)
```

## Union Types for Multiple Error Types

```scala
import ox.either
import ox.either.ok

val v1: Either[DatabaseError, String] = ???
val v2: Either[NetworkError, String] = ???

// Errors are combined in union type
val result: Either[DatabaseError | NetworkError, String] = either:
  v1.ok() ++ v2.ok()
```

## Error Modes for Advanced Scenarios

```scala
import ox.{supervisedError, EitherMode}

// Use supervisedError for application error propagation
given ErrorMode[String] = EitherMode[String]

supervisedError {
  val f1 = forkError {
    Left("application error") // Propagated as value, not exception
  }
  f1.join() // Either[String, ResultType]
}
```

## Best Practices

### Use Exceptions For
- Bugs and programming errors
- Unexpected system failures
- Integration with Java libraries that throw
- Violations of preconditions/invariants

### Use Application Errors For
- Expected business logic failures
- Validation errors
- API error responses
- Type-safe error handling

### Working with Eithers
- use the `either` block within which `Either` values can be unwrapped using `.ok()`

## Exception Conversion

Convert exceptions to values when needed:

```scala
import ox.either

// Convert exception-throwing code to Either
val result: Either[Throwable, String] = either.catching {
  riskyOperationThatThrows()
}

// Handle specific exception types
val result2: Either[SQLException, List[User]] = either.catching {
  databaseQuery()
}.recover {
  case _: ConnectionException => Left(ConnectionError)
}
```

## Avoid

```scala
// Don't mix error handling approaches inconsistently
def badExample(): Either[String, User] = {
  if (condition) throw new Exception("mixed approach") // Bad!
  else Right(user)
}

// Don't swallow exceptions without handling
try {
  riskyOperation()
} catch {
  case _ => // Bad - don't ignore errors
}
```
