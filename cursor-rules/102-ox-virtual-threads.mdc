---
description: 
globs: *.scala
alwaysApply: false
---
# Ox Virtual Threads

Ox leverages Java 21 virtual threads, making blocking operations cheap and efficient. Don't be afraid to block or create many concurrent forks.

## Key Principles

- **Blocking is cheap**: Virtual threads have low memory footprint and fast context switching
- **Create many forks**: Thousands of virtual threads can run efficiently
- **No thread pool management**: Virtual threads are managed by the JVM runtime
- **Direct blocking**: No need for asynchronous programming patterns

## Good Examples

```scala
import ox.{fork, supervised, sleep}
import scala.concurrent.duration.*

// Creating many concurrent operations
supervised {
  val forks = (1 to 1000).map { i =>
    fork {
      sleep(1.second) // Blocking is fine!
      processItem(i)
    }
  }
  forks.map(_.join())
}

// Blocking I/O operations
def fetchFromDatabase(): List[User] =
  // This blocks, but that's perfectly fine with virtual threads
  databaseConnection.query("SELECT * FROM users")

def processFiles(): Unit =
  supervised {
    val files = listFiles()
    files.map { file =>
      fork {
        // Blocking file I/O
        val content = Files.readString(file.toPath)
        processContent(content)
      }
    }.foreach(_.join())
  }
```

## Benefits of Virtual Threads

- **High throughput**: Handle millions of concurrent requests
- **Low memory usage**: ~200 bytes per virtual thread vs ~2MB per platform thread
- **Fast creation**: Creating virtual threads is very cheap
- **Familiar programming model**: Use blocking APIs without performance penalties

## Blocking Operations That Are Efficient

```scala
// All of these are efficient with virtual threads:
val data = httpClient.get(url) // HTTP requests
val result = database.query(sql) // Database queries  
val content = Files.readString(path) // File I/O
val response = socket.read() // Network I/O
Thread.sleep(duration) // Sleeping/delays
```

## Avoid Unnecessary Complexity

```scala
// Don't use callback-style when you can block
// Bad:
httpClient.getAsync(url, callback)

// Good:
val response = httpClient.get(url)

// Don't limit concurrent operations artificially
// Bad:
val executor = Executors.newFixedThreadPool(10)

// Good: Create as many forks as needed
supervised {
  items.map(item => fork { process(item) })
}
```

## Usage Tips

- Virtual threads shine with I/O-bound operations
- CPU-bound tasks might be better served by running on a dedicated thread pool
- Use `forkUser` when you need to wait for all operations to complete
- Prefer high-level operations (`par`, `race`) which avoid creating scopes manually
