---
description: Prefer high-level operations (`par`, `race`, `timeout`) over manual fork/join patterns when possible for better readability and safety.
globs: 
alwaysApply: false
---
# Ox High-Level Operations

Prefer high-level operations like `par`, `race`, and `timeout` over manual fork/join patterns for better readability, safety, and composability.

## High-Level Operations Overview

Ox provides several high-level operations that handle common concurrency patterns:

- **`par`**: Run computations in parallel, wait for all to complete
- **`race`**: Run computations concurrently, return first result
- **`raceSuccess`**: Run computations concurrently, return first successful result
- **`timeout`**: Run computation with a time limit
- **`either`**: Handle application errors elegantly

## Using `par` for Parallel Execution

```scala
import ox.par
import scala.concurrent.duration.*

// Good: Using par for parallel execution
val result: (String, Int, Boolean) = par(
  fetchUserName(userId),
  calculateScore(data),
  checkPermissions(userId)
)

// Avoid: Manual fork/join for simple parallel execution
// Less readable and more error-prone
supervised {
  val f1 = forkUser { fetchUserName(userId) }
  val f2 = forkUser { calculateScore(data) }
  val f3 = forkUser { checkPermissions(userId) }
  (f1.join(), f2.join(), f3.join())
}
```

## Using `race` for Competing Computations

```scala
import ox.{race, raceSuccess}

// Good: Race for first completion
val result = race(
  primaryService.getData(),
  fallbackService.getData()
)

// Good: Race for first successful result
val result2 = raceSuccess(
  primaryService.getData(),    // might throw
  fallbackService.getData(),   // might throw
  cacheService.getData()       // fallback
) // Returns first successful result, cancels others

// Avoid: Manual racing with fork/join
supervised {
  val f1 = forkUser { primaryService.getData() }
  val f2 = forkUser { fallbackService.getData() }
  
  // Complex manual logic to handle first completion
  // ... error-prone cancellation logic
}
```

## Using `timeout` for Time-Limited Operations

```scala
import ox.timeout
import scala.concurrent.duration.*

// Good: Simple timeout usage
val result = timeout(5.seconds) {
  expensiveNetworkCall()
}

// Good: Timeout with fallback
val result2 = try {
  timeout(2.seconds) { primaryService.call() }
} catch {
  case _: TimeoutException => fallbackService.call()
}

// Avoid: Manual timeout implementation
supervised {
  val mainFork = forkUser { expensiveNetworkCall() }
  val timeoutFork = fork {
    sleep(5.seconds)
    throw new TimeoutException("Operation timed out")
  }
  
  race(mainFork.join(), timeoutFork.join())
}
```

## Combining High-Level Operations

High-level operations compose naturally:

```scala
import ox.{par, race, timeout, either}
import scala.concurrent.duration.*

// Complex operation combining multiple patterns
def fetchUserData(userId: String): Either[String, UserData] = either {
  val basicInfo = timeout(2.seconds) {
    userService.getBasicInfo(userId)
  }
  
  val (profile, preferences) = par(
    timeout(3.seconds) { profileService.getProfile(userId) },
    timeout(1.second) { preferencesService.getPreferences(userId) }
  )
  
  val avatar = race(
    cdnService.getAvatar(userId),
    fallbackService.getDefaultAvatar()
  )
  
  UserData(basicInfo, profile, preferences, avatar)
}
```

## Application Error Handling with High-Level Ops

```scala
import ox.{parError, raceError, EitherMode}

given ErrorMode[String] = EitherMode[String]

// Good: High-level operations with application errors
val result: Either[String, (User, Settings)] = parError(
  fetchUser(userId).fold(Left(_), Right(_)),
  fetchSettings(userId).fold(Left(_), Right(_))
)

val winner: Either[String, Data] = raceError(
  primaryAPI.getData().fold(Left(_), Right(_)),
  fallbackAPI.getData().fold(Left(_), Right(_))
)
```

## When Manual Fork/Join is Appropriate

Use manual fork/join only when high-level operations don't fit:

```scala
// Appropriate: Complex control flow
supervised {
  val authFork = forkUser { authenticate(request) }
  val auth = authFork.join()
  
  if (auth.isAdmin) {
    val adminDataFork = forkUser { fetchAdminData() }
    val auditFork = fork { logAdminAccess(auth.userId) }
    adminDataFork.join()
  } else {
    val userDataFork = forkUser { fetchUserData(auth.userId) }
    userDataFork.join()
  }
}
```

## Error Handling Benefits

High-level operations provide consistent error handling:

```scala
// Good: Automatic error propagation and cleanup
val result = par(
  riskyOperation1(),  // If this throws, others are cancelled
  riskyOperation2(),  // If this throws, others are cancelled
  riskyOperation3()   // If this throws, others are cancelled
)

// Error-prone: Manual error handling
supervised {
  val f1 = forkUser { riskyOperation1() }
  val f2 = forkUser { riskyOperation2() }
  val f3 = forkUser { riskyOperation3() }
  
  try {
    (f1.join(), f2.join(), f3.join())
  } catch {
    case e =>
      // Manual cleanup needed
      // Complex cancellation logic
      throw e
  }
}
```

## Common Patterns

### Parallel with Timeout

```scala
// Good: Combining par and timeout
val result = timeout(10.seconds) {
  par(
    fetchData1(),
    fetchData2(),
    fetchData3()
  )
}
```

### Conditional Parallel Execution

```scala
// Good: Using par conditionally
def fetchUserData(userId: String, includePreferences: Boolean) = {
  val basicData = fetchBasicData(userId)
  
  if (includePreferences) {
    val (profile, preferences) = par(
      fetchProfile(userId),
      fetchPreferences(userId)
    )
    UserData(basicData, Some(profile), Some(preferences))
  } else {
    UserData(basicData, None, None)
  }
}
```

## Best Practices

1. **Start with high-level operations** - they handle common patterns safely
2. **Use `par`** for independent parallel computations
3. **Use `race`** when you need the first result
4. **Use `timeout`** for operations that might hang
5. **Combine operations** for complex scenarios
6. **Fall back to fork/join** only when high-level ops don't fit
7. **Prefer `raceSuccess`** over `race` when failures are expected
8. **Use error-handling variants** (`parError`, `raceError`) for application errors
