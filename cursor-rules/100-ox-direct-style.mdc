---
description: 
globs: *.scala
alwaysApply: false
---
# Ox Direct-Style Programming

Ox uses direct-style programming where effectual computations return values directly without wrapper types like `Future`, `IO`, or `Task`. This leverages Java 21 virtual threads for high-performance concurrency.

## Core Principles

- **Direct return values**: Methods return actual values, not wrapped types
- **Built-in control flow**: Use standard language constructs (if/else, for loops, try/catch)
- **Virtual threads**: Blocking operations are cheap and efficient
- **No coloring**: No need for special syntax like `async`/`await`

## Good Examples

```scala
// Direct-style: values returned directly
def fetchData(): String = 
  val response = httpClient.get("https://api.example.com/data")
  response.body

def processData(): List[String] =
  val data = fetchData()
  data.split(",").toList

// Combining operations naturally
def pipeline(): Int =
  val data = fetchData()
  val processed = processData()
  processed.length
```

## Avoid

```scala
// Don't use wrapper types like Future, IO, Task
def fetchData(): Future[String] = ???
def fetchData(): IO[String] = ???
def fetchData(): Task[String] = ???

// Don't use callback-style programming
def fetchData(callback: String => Unit): Unit = ???
```

## Key Benefits

- **Natural error handling**: Use try/catch for exceptions
- **Simple control flow**: Standard if/else, loops, pattern matching
- **Performance**: Virtual threads provide high throughput without callback complexity
- **Readability**: Code reads like synchronous code but runs asynchronously

## Integration

Direct-style works seamlessly with blocking I/O operations, database calls, and HTTP requests, all efficiently managed by virtual threads under the hood.
