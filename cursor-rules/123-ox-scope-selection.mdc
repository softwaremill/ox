---
description: Choose appropriate scope types: `supervised` for error propagation, `supervisedError` for application error handling, `unsupervised` for manual error management.
globs: 
alwaysApply: false
---
# Ox Scope Selection Guide

Choose the right scope type based on your error handling and concurrency management needs.

## Scope Types Overview

1. **`supervised`**: Default choice with automatic error propagation
2. **`supervisedError`**: For application errors that should propagate as values
3. **`unsupervised`**: For manual error management and control

## When to Use `supervised`

Use `supervised` as the default for most concurrent operations:

```scala
import ox.{fork, forkUser, supervised}

// Default choice: automatic error propagation
def processDataConcurrently(data: List[Data]): List[Result] = supervised {
  data.map { item =>
    fork { processItem(item) } // Any exception ends the entire scope
  }.map(_.join())
}

// Web request handling
def handleApiRequest(request: Request): Response = supervised {
  val authFork = fork { authenticate(request) }
  val dataFork = fork { fetchData(request.id) }
  val validationFork = fork { validateRequest(request) }
  
  // If any fork throws, entire request fails fast
  Response(
    auth = authFork.join(),
    data = dataFork.join(),
    validation = validationFork.join()
  )
}

// Background job processing
def processJob(job: Job): Unit = supervised {
  forkUser { updateJobStatus(job.id, "PROCESSING") }
  forkUser { performJobWork(job) }
  forkUser { updateJobStatus(job.id, "COMPLETED") }
  // All steps must complete successfully
}
```

## When to Use `supervisedError`

Use `supervisedError` for business logic that can fail with expected errors:

```scala
import ox.{supervisedError, forkError, EitherMode}

given ErrorMode[String] = EitherMode[String]

// Business validation that can fail
def validateUserRegistration(userData: UserData): Either[String, ValidatedUser] = 
  supervisedError {
    val emailFork = forkError {
      if (isValidEmail(userData.email)) Right(userData.email)
      else Left("Invalid email format")
    }
    
    val ageFork = forkError {
      if (userData.age >= 18) Right(userData.age)
      else Left("Must be 18 or older")
    }
    
    val usernameFork = forkError {
      if (isUsernameAvailable(userData.username)) Right(userData.username)
      else Left("Username already taken")
    }
    
    // Errors propagate as values, not exceptions
    ValidatedUser(
      email = emailFork.join(),
      age = ageFork.join(),
      username = usernameFork.join()
    )
  }

// API integration with expected failures
def fetchExternalData(sources: List[DataSource]): Either[ApiError, CombinedData] =
  supervisedError {
    val results = sources.map { source =>
      forkError {
        apiClient.fetch(source).fold(
          error => Left(ApiError(source.name, error)),
          data => Right(data)
        )
      }
    }
    
    CombinedData(results.map(_.join()))
  }
```

## When to Use `unsupervised`

Use `unsupervised` when you need full control over fork lifecycle and error handling:

```scala
import ox.{unsupervised, forkUnsupervised}

// Custom error handling strategy
def processWithRetries(items: List[Item]): List[ProcessResult] = unsupervised {
  val forks = items.map { item =>
    forkUnsupervised {
      var attempts = 0
      var result: Option[ProcessResult] = None
      
      while (attempts < 3 && result.isEmpty) {
        try {
          result = Some(processItem(item))
        } catch {
          case e: RetryableException =>
            attempts += 1
            if (attempts < 3) Thread.sleep(1000 * attempts)
          case e: FatalException =>
            return ProcessResult.Failed(e.getMessage)
        }
      }
      
      result.getOrElse(ProcessResult.Failed("Max retries exceeded"))
    }
  }
  
  // Manual error handling - collect all results
  forks.map { fork =>
    try {
      fork.join()
    } catch {
      case e => ProcessResult.Failed(e.getMessage)
    }
  }
}

// Fire-and-forget operations
def startBackgroundTasks(): Unit = unsupervised {
  val logCleanupFork = forkUnsupervised { cleanupLogs() }
  val cacheWarmupFork = forkUnsupervised { warmupCache() }
  val metricsReportFork = forkUnsupervised { reportMetrics() }
  
  // Don't wait for completion, let them run independently
  // Scope ends immediately
}
```

## Combining Scope Types

You can nest different scope types for complex scenarios:

```scala
def complexProcessing(data: ProcessingRequest): ProcessingResult = supervised {
  // Phase 1: Validation (business errors expected)
  val validationResult = supervisedError {
    val f1 = forkError { validateInput(data.input) }
    val f2 = forkError { checkPermissions(data.user) }
    val f3 = forkError { verifyQuota(data.user) }
    
    (f1.join(), f2.join(), f3.join())
  }
  
  validationResult match {
    case Left(error) => ProcessingResult.ValidationFailed(error)
    case Right((input, permissions, quota)) =>
      
      // Phase 2: Processing (system errors should fail fast)
      supervised {
        val processingFork = fork { processData(input) }
        val auditFork = fork { auditAccess(data.user, permissions) }
        
        ProcessingResult.Success(
          result = processingFork.join(),
          audit = auditFork.join()
        )
      }
  }
}
```

## Best Practices

1. **Start with `supervised`** - use as default unless you have specific needs
2. **Use `supervisedError`** for business logic validation and expected failures
3. **Use `unsupervised`** sparingly, only when you need full control
4. **Don't mix concerns** - keep error handling strategies consistent within a scope
5. **Document your choice** - make scope selection reasoning explicit
6. **Test error scenarios** - ensure your scope choice handles errors as expected

## Common Mistakes

```scala
// Bad: Using unsupervised when supervised would work
unsupervised {
  val f = forkUnsupervised { simpleTask() }
  f.join() // Just use supervised instead
}

// Bad: Using supervised for expected business failures
supervised {
  fork { 
    if (user.age < 18) throw new ValidationException() // Should be Either
  }
}

// Bad: Mixing error handling approaches in same scope
supervisedError {
  forkError { businessValidation() } // Returns Either
  fork { throw new Exception() } // Throws - inconsistent!
}
```
