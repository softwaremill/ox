---
description: Avoid returning `Fork` objects from methods to prevent accidental concurrency. Model concurrency at the caller level instead.
globs: 
alwaysApply: false
---
# Ox Avoid Fork Return

Avoid returning `Fork` objects from methods to prevent accidental concurrency. Model concurrency at the caller level instead.

**Bad - returning Fork objects:**
```scala
// Don't do this - leaks concurrency details
def startBackgroundProcess()(using Ox): Fork[Unit] = fork {
  while (true) {
    processData()
    sleep(1.second)
  }
}

// Caller must manage fork lifecycle
supervised {
  val backgroundFork = startBackgroundProcess()
  // ... do other work ...
  backgroundFork.cancel() // Easy to forget!
}
```

**Good - model concurrency at call site:**
```scala
// Better - just provide the computation
def runBackgroundProcess(): Unit = 
  while (true) {
    processData()
    sleep(1.second)
  }

// Caller controls concurrency model
supervised {
  forkUser { runBackgroundProcess() } // Explicit fork management
  // ... do other work ...
  // Automatic cleanup when scope ends
}
```

**Good - return values, not forks:**
```scala
// Computation that can be forked
def computeResult(input: Data): Result = 
  expensiveComputation(input)

// Caller decides on concurrency
supervised {
  val f1 = fork { computeResult(data1) }
  val f2 = fork { computeResult(data2) }
  (f1.join(), f2.join())
}
```

**Exception - when Fork management is the point:**
```scala
// Acceptable when Fork is the main abstraction
trait WorkerPool {
  def submitTask[T](mdc:task: () => T)(using Ox): Fork[T]
}
```

**Benefits of avoiding Fork returns:**
- Clear concurrency boundaries
- Easier resource management
- Less chance of fork leaks
- Simpler testing
- Better composability
