---
description: Integrate callback-based APIs using channels and `Flow.usingEmit` for safe bridging between structured and unstructured concurrency.
globs: 
alwaysApply: false
---
# Ox Callback Integration

Integrate callback-based APIs using channels and `Flow.usingEmit` for safe bridging between structured and unstructured concurrency.

**Callback to Flow integration:**
```scala
def eventFlow()(using Ox, BufferCapacity): Flow[Event] = 
  Flow.usingEmit { emit =>
    val subscription = eventSystem.subscribe { event =>
      emit(event) // Bridge callback to structured flow
    }
    
    // Cleanup when flow ends
    onComplete(subscription.cancel())
  }
```

**WebSocket integration:**
```scala
def websocketFlow(url: String)(using Ox, BufferCapacity): Flow[Message] = 
  Flow.usingEmit { emit =>
    val socket = new WebSocket(url) {
      override def onMessage(message: Message): Unit = {
        emit(message) // Forward messages to flow
      }
      
      override def onError(error: Throwable): Unit = {
        emit.error(error) // Forward errors
      }
      
      override def onClose(): Unit = {
        emit.done() // Signal completion
      }
    }
    
    socket.connect()
    onComplete(socket.close())
  }
```

**Channel-based callback integration:**
```scala
def subscribeToQueue()(using Ox, BufferCapacity): Source[Message] = 
  val channel = BufferCapacity.newChannel[Message]
  
  val consumer = messageQueue.createConsumer { message =>
    channel.send(message) // Thread-safe channel send
  }
  
  // Cleanup on scope end
  onScopeEnded(consumer.close())
  channel
```

**Async callback with completion:**
```scala
def asyncOperation[T](mdc:operation: Callback[T] => Unit)(using Ox): T = 
  val promise = Promise[T]()
  
  operation { result =>
    promise.success(result) // Bridge callback to future
  }
  
  promise.future.await() // Block until callback completes
```

**Multi-callback aggregation:**
```scala
def aggregateCallbacks()(using Ox, BufferCapacity): Flow[AggregatedData] = 
  Flow.usingEmit { emit =>
    val subscription1 = source1.subscribe(data => emit(Data1(data)))
    val subscription2 = source2.subscribe(data => emit(Data2(data)))
    val subscription3 = source3.subscribe(data => emit(Data3(data)))
    
    onComplete {
      subscription1.cancel()
      subscription2.cancel()
      subscription3.cancel()
    }
  }
```

**Benefits:**
- Safe integration with callback-based libraries
- Automatic cleanup and resource management
- Error propagation from callbacks to structured code
- Backpressure support when using channels
